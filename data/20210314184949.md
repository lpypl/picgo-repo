## 3.13（lpy）
1. 考虑到OceanBase大部分操作与MySQL相同，AdapterOceanBase改为继承AdapterMySQL
1. 添加了一部分配置类，用于配置改造，从而避免程序完全依赖整个XML文件，便于进行单元测试

## 3.12（lpy）
1. 按照START操作的配置设置读写模式和快照模式（适配MySQL，PG还无法实现快照模式设置
1. 新增TransactionLoaderConfig，可以使用yaml或xml格式的配置，当前仅支持配置线程数和每个线程执行次数，  
   建议使用yaml，示例如下
   ```yaml
   numberOfLoader: 4
   execCountPerLoader: 4
   ```

## 3.11（lpy）
1. 为OceanBase适配隔离级别，官方文档说mysql模式只支持两种隔离级别，
   但除了Uncommitted模式都可以执行成功，所以就用了三种
![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210311150937.png)
1. OceanBase 不支持select ... share in lock mode
1. 为Start设置LockMode和ReadMode

## 3.11(wsy)
1. 增加了`abstractTable.getDataType(String attributeName)`，用于获取属性名对应的数据类型
2. 修正了`OperationStart`中关于只读和快照的两个选项
3. 删除了xml中不需要范围限定时的范围值，并更新了`SeedUtil`和`Seed`

## 3.10(wsy)
1. 更新了predicate lock的语句
2. 更新了两种start语句

## 3.10（lpy）
### 更新
1. UPDATE失败时ROLLBACK
1. 适配OceanBase
    1. 将外键创建语句放到了建表语句中
    1. 注释掉了隔离级别设置语句，因为会报错
        ```text
       java.sql.SQLException: Not supported feature or function
        at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1056)
        at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:957)
        at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3376)
        at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3308)
        at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:1837)
        at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:1961)
        at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2537)
        at com.mysql.jdbc.ConnectionImpl.setTransactionIsolation(ConnectionImpl.java:5148)
        at load.TransactionLoader.lambda$loadTransactionAsync$0(TransactionLoader.java:114)
        at java.lang.Thread.run(Thread.java:748)
       ```
### 已知问题
1. timestamp类型无法转换为逻辑值

## 3.9（lkq）
1.引入了satisfy predicate的相关代码，见ana.satisfy package
2.进一步完善多粒度锁的验证工作
3.修改了随机模型生成多种case，发现存在多种问题

## 3.9（lkq）
1. 优化了ana程序结构
1. 测试通过读一致性验证算法
1. 测试通过first-updater-wins算法
1. pull lpy代码，pull wsy代码


## 3.8（lpy）
1. 修改分区算法，允许初始化部分动态数据（原本只分为STATIC和DYNAMIC)
1. 重构了初始数据生成部分代码
1. TODO：初始化数据生成时为DYNAMIC_EXISTS部分建立引用信息
1. 初始化数据生成时已构造引用信息，但是其paramFillInfo部分为null

## 3.7（lkq）
1. debug读一致性验证的代码，发现获取当前活跃事务存在bug，需要从profile中获取当前活跃事务，而不是读一致性验证的write set

## 3.7（lpy）
1. 优化真实值到逻辑值的转换
1. 去除对table的select操作的trace的valueMap中的主键属性
1. 去除推算的逻辑值中的主键属性

## 3.7（wsy）

1. 实现了predicateLock的重写，对应的语句会作为json的predicate参数输出
   1. 除了需要predicateLock的语句，其他情况下输出空字符串

## 3.6（lpy）
1. 修复LOCK_MODE改名引起的BUG
1. 添加READ_MODE

## 3.5(wsy)
1. 为view的select添加了重合属性
2. 补充了view的接口，使之能够返回属性所对应的原本属性列表
补充了TraceLockMode中缺少的一些枚举型，请注意检查这部分补充是否需要再调整

## 3.4（lkq）
在operationtrace中增加一个域readmode,区分处理lockmode和readmode

## 3.4（lpy）
1. Trace尝试适配VIEW，但是似乎由于SELECT结果并不一定包含JOIN部分属性，
   所以结果可能并不直观

## 3.3（lpy）
1. 初始化DYNAMIC_EXISTS
1. millTime -> nanoTime
1. 修复初始逻辑值计算BUG

## 3.2（lpy）
1. 序列化MiniShadow，提供生成初始值接口
1. 逻辑值转换优化
1. TupleTrace的table字段存储tableId

## 3.1（lpy）
1. 事务开始随机设置隔离级别
1. trace添加隔离级别

## 2.28（lpy）
1. update操作添加WriteTupleList
1. ROLLBACK添加错误原因

## 2.27（lpy）
1. 执行出错时ROLLBACK
1. 需要selectInfoList列信息出现顺序与select结果保持一致，暂且假定是一致的
1. 由于级联引用难以处理，暂时关闭了前缀外键
   ![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210227232807.png)
1. 关闭前缀外键之后，select结果可以转换成了逻辑值，不过对于double，decimal无法精确转换

## 2.26（lpy）
1. 使用新的Trace格式
1. 添加了START和COMMIT的trace

## 当前问题
1. SELECT操作未使用逻辑值，未添加pkId，因为涉及到动态搜索，不一定可以完成逆运算
1. 有些操作可能无法执行，比如UPDATE，这时候应该如何处理？


## 2.26(wsy)
实现了insert和delete模板相互转换的构造函数
1. 使用形如new OperationInsert(OperationDelete)的方式调用
2. insert转为delete时，只会保留主键的信息，即where后只有pk，原本insert的非主属性不会出现在模板中
3. **需要注意的是，目前的实现均是基于主键点写的，即转换后只保留主键点写的信息（在目前的情况下，只会产生2.中所说的损失）。如果要扩展的话可能需要重新修改。**

## 2.25（lpy）
1. INSERT/DELETE/UPDATE属性值改成了逻辑值，SELECT操作暂时没法改逻辑值
1. 修改了事务加载方式，先产生一批事务模板，然后创建若干TransactionLoader，
   每个Loader在单独线程中执行若干次事务后结束

## 2.24（lpy）
1. 修改了MiniShadow，可以通过tableId和pkId计算初始值
1. INSERT,DELETE,UPDATE的TupleTrace添加了pkId
1. INSERT操作中的列值改成了逻辑值，为pkId，fkId或attrId

## 现在的问题
1. INSERT和DELETE的转换需要继续修改，现在的实现有问题

## 2.22（lpy）
1. 为select操作的Trace添加readTupleList
1. 为delete和insert操作的Trace添加了writeTupleList
1. 去除predicate的`"where "`前缀

## 2.21（lpy）
1. trace记录格式优化

## 2.19（lpy）
1. trace记录初步实现
1. trace优化，可以流式读写
1. TransactionTraceReader,TransactionTraceWriter

## 2.5（lpy）
1. 尝试适配View但又基本恢复了原来的代码，View涉及的代码比较多
1. Select操作难以适配View（其他操作不涉及View），可能需要重构View类
1. 修修补补适配了View，通过在构建View的时候构造ParamFillInfo，
   为Select操作适配了View，也许Table也可以这么操作，甚至可以更进一步直接把
   ParamFillInfo 中的信息添加到 Attribute 中
   
## 2.4（lpy）

1. 修改了Update操作模板，不允许修改主键
2. 现在的事务中包含增删改查四种基本操作
3. 可能RefInfo类中的Map的key需要改一下，现在用的是attr.name，这样适用于fromTable，
   但应该不适用于toTable， 因为可能有多个表的同名attr引用该表的属性（已修改）
4. 现在的事务似乎无法处理View，对Table基本能执行成功   

## 2.3 (wsy)

1. 完成了四种基础操作中对ParamFillInfo的正确加入
2. 修复了原来in和between对应参数数量不一致的问题
3. 在operation.xml中添加了`select/where_clause/predicate/in_num`的属性，用于确定生成in对应参数数量的种子。完成了其数量的随机初始化。
4. 修复了delete操作存在的语义不符合要求的问题。

### 测试中出现的一些语义问题

1. 在进行修改或删除操作时的外键依赖问题
2. 进行修改时偶尔会出现主键重复导致修改失效的问题

## 2.3（lpy）
1. 静态数据生成添加了pkId这一列 
1. 动态数据生成中，Insert操作也添加了pkId这一列，
   改动主要涉及OperationInsert中genParamFillInfo和toSQL函数，没有修改其内部逻辑，
   只是在toSQL中添加了一个pkId列，并在ParamFillInfo中添加了一个以指示pkId的填充
1. 尝试在执行删除操作时解决多级依赖的问题，但是并不能确定是否已经解决，还需要实际测试   
1. 现在的删除操作会尝试寻找一定次数，如果无法找到可供删除的行，则放弃该操作，
   如果想要转换成插入操作，一个比较容易的方法是，在OperationInsert中添加一个构造函数，
   将OperationDelete转换成OperationInsert，反之亦然

## 2.2（lpy）

1. 事务加载部分初步适配插入和删除操作，涉及多级引用的地方需要继续修改
1. 现在的各种插入操作可能需要添加pkId列

## 2.1（lpy）
1. 似乎由于动态数据存在随机性，无法在级联删除时推算出某些外键值，
   也许可以考虑在每张表中添加一列， 名为pkId，便于根据pkId进行程序内部操作，
   比如按照pkId级联删除
1. 为每张表添加了一列`pkId`，用于存储每一行数据对应的`pkId`，
   以避免在一些代码中根据`pkId`推算该行的具体数据值，该操作在adapter中实现
   ![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210201235943.png)
1. 去除了Insert操作中静态区被参考项仅限于静态区的限制   
1. 在Reference中添加了ParamFillInfo，也许现在的信息足以确定动态生成的前缀外键具体值

## 1.29（lpy）
1. `loadInsertOperation`在一个插入模板的参数填充过程中，只为一个ForeignKey生成一个fkId，
   该ForeignKey的多个属性都使用这一个fkId生成最终数据。fkId的范围暂时限定为静态区，
   可以保证生成数据有效
1. 借助互斥锁实现了只包含插入操作的多个事务并行加载  

## 1.28 v2（lpy）
1. 为`UPDATE,INSERT,SELECT,DELETE`简单适配了事务加载，但是现在基本是随机确定的值，
   现在还不清楚应该按照什么原则确定值
1. 静态数据生成时的BUG，可能是因为table2所参考的table1对应行的主键可以确定，
   但那一行由于其外键约束无法被满足而没有生成。这也许算是另一种级联外键带来的问题。
   似乎比`table2.fkAttr0->table1.pkAttr0->table0.pkAttr0`更难以处理（基本解决，见下一条）
1. 静态数据生成时加上了fkId搜索这个步骤，确保静态区数据全部生成，似乎可以正确地生成初始数据了   
1. 现在的负载模板过于随机，难以按照模板控制MiniShadow，需要限制语义
   ![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210128203331.png)  

## 1.28（lpy）
1. 以类似于PKF的方式，增加了`pkId->attrId`的随机性，暂时没有使用分布来确定`attrId`
1. 对`pkId-fkId`做了和上一条同样的处理
1. 现在的情况是，程序并不保证`pkId->attrId`，`pkId-fkId`转换结果的有效性，
   甚至并不保证转换得到的`fkId`一定在目标表的有效`pkId`范围内，
   因此需要该操作的用户根据当时的需求搜索得到有效值。现在并不能确定这样处理是否合理。
1. 似乎由于级联引用引发了BUG，`fk->pk->pk`，生成静态数据时可能需要递归搜索，现在只考虑了一层外键引用
1. 尝试进行了上一条所说的操作，好像偶尔还会在初始数据生成时出错，有时可以在级联引用时正常运行
1. 如果允许级联引用，文档中所述的fkId搜索可能难以实现，假如`table2.fkAttr0->table1.pkAttr0->table0.pkAttr0`具体又该如何处理

### BUG
1. 有参数未填充，有可能是因为负载模板添加信息遗漏了BetweenAnd的后一个参数![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210128024015.png)
1. 静态数据生成BUG，与外键有关
   ```text
   [INFO             orca.Orca]   Loading initial data to database: mysql-db0
   Exception in thread "main" java.sql.BatchUpdateException: Cannot add or update a child row: a foreign key constraint fails (`db0`.`table2`, CONSTRAINT `commFk_2_fkAttr0` FOREIGN KEY (`fkAttr0`) REFERENCES `table1` (`pkAttr0`))
   at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
   at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
   at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
   at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
   at com.mysql.cj.util.Util.handleNewInstance(Util.java:192)
   at com.mysql.cj.util.Util.getInstance(Util.java:167)
   at com.mysql.cj.util.Util.getInstance(Util.java:174)
   at com.mysql.cj.jdbc.exceptions.SQLError.createBatchUpdateException(SQLError.java:224)
   at com.mysql.cj.jdbc.StatementImpl.executeBatchInternal(StatementImpl.java:893)
   at com.mysql.cj.jdbc.StatementImpl.executeBatch(StatementImpl.java:796)
   at load.SQLLoader.loadSQLList(SQLLoader.java:19)
   at orca.Orca.main(Orca.java:104)
   Caused by: java.sql.SQLIntegrityConstraintViolationException: Cannot add or update a child row: a foreign key constraint fails (`db0`.`table2`, CONSTRAINT `commFk_2_fkAttr0` FOREIGN KEY (`fkAttr0`) REFERENCES `table1` (`pkAttr0`))
   at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:117)
   at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
   at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
   at com.mysql.cj.jdbc.StatementImpl.executeUpdateInternal(StatementImpl.java:1335)
   at com.mysql.cj.jdbc.StatementImpl.executeBatchInternal(StatementImpl.java:859)
   ... 3 more
   
   Process finished with exit code 1

   ```

### 问题
1. 参数模板里的视图暂未考虑，视图的参数信息能否像table一样填充
   ```text
   [INFO  load.TransactionLoader]   SQL is: select view0_0_table2.pkAttr0, view0_0_table2.coAttr0, view0_0_table2.coAttr1, view0_0_table2.coAttr2, view0_0_table2.coAttr3 from view0 where ( NOT view0_0_table2.pkAttr0 = ? ) for update order by (view0_0_table2.pkAttr0);
   [INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ClientPreparedStatement: select view0_0_table2.pkAttr0, view0_0_table2.coAttr0, view0_0_table2.coAttr1, view0_0_table2.coAttr2, view0_0_table2.coAttr3 from view0 where ( NOT view0_0_table2.pkAttr0 = ** NOT SPECIFIED ** ) for update order by (view0_0_table2.pkAttr0);
   Exception in thread "main" java.sql.SQLException: No value specified for parameter 1
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:129)
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
       at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeQuery(ClientPreparedStatement.java:1020)
       at load.TransactionLoader.loadSelectOperation(TransactionLoader.java:131)
       at load.TransactionLoader.loadTransaction(TransactionLoader.java:53)
       at orca.Orca.main(Orca.java:118)
   
   Process finished with exit code 1
   ```
1. 生成的参数模板无法执行，可能语法存在问题或者需要适配特定的数据库
   
   for update的位置对不对（已修正，移动至末尾好像就行了）
   ```text
   [INFO  load.TransactionLoader]   SQL is: select pkAttr0, pkAttr1, coAttr0, coAttr1, coAttr2, coAttr3 from table2 where ( coAttr0 = ? ) and ( coAttr1 = ? ) and ( NOT coAttr2 = ? ) and ( coAttr3 = ? ) lock in shared mode order by (pkAttr0, pkAttr1, coAttr0, coAttr1);
   [INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ClientPreparedStatement: select pkAttr0, pkAttr1, coAttr0, coAttr1, coAttr2, coAttr3 from table2 where ( coAttr0 = 55374.0699478078 ) and ( coAttr1 = 29947.86307890177 ) and ( NOT coAttr2 = 51758.95190630357 ) and ( coAttr3 = 94156.19208638351 ) lock in shared mode order by (pkAttr0, pkAttr1, coAttr0, coAttr1);
   Exception in thread "main" java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'shared mode order by (pkAttr0, pkAttr1, coAttr0, coAttr1)' at line 1
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:120)
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
       at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:953)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeQuery(ClientPreparedStatement.java:1003)
       at load.TransactionLoader.loadSelectOperation(TransactionLoader.java:131)
       at load.TransactionLoader.loadTransaction(TransactionLoader.java:53)
       at orca.Orca.main(Orca.java:118)
   ```
   
   order by 后面的列名可能不能加括号（已修改对应的toSQL，去掉了括号）
   ```text
   [INFO  load.TransactionLoader]   SQL is: select pkAttr0, pkAttr1, coAttr4, coAttr5, coAttr6, coAttr7 from table0  for update order by (pkAttr0, pkAttr1, coAttr4, coAttr5, coAttr6);
   [INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ClientPreparedStatement: select pkAttr0, pkAttr1, coAttr4, coAttr5, coAttr6, coAttr7 from table0  for update order by (pkAttr0, pkAttr1, coAttr4, coAttr5, coAttr6);
   Exception in thread "main" java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'order by (pkAttr0, pkAttr1, coAttr4, coAttr5, coAttr6)' at line 1
   at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:120)
   at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
   at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
   at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:953)
   at com.mysql.cj.jdbc.ClientPreparedStatement.executeQuery(ClientPreparedStatement.java:1003)
   at load.TransactionLoader.loadSelectOperation(TransactionLoader.java:131)
   at load.TransactionLoader.loadTransaction(TransactionLoader.java:53)
   at orca.Orca.main(Orca.java:118)
   
   Process finished with exit code 1
   ```
   
   lock语句要怎么改（已修正，`shared->share`）
   ```text
   [INFO  load.TransactionLoader]   SQL is: select pkAttr0, pkAttr1, coAttr4, coAttr5, coAttr6, coAttr7 from table0  lock in shared mode order by pkAttr0, pkAttr1, coAttr4;
   [INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ClientPreparedStatement: select pkAttr0, pkAttr1, coAttr4, coAttr5, coAttr6, coAttr7 from table0  lock in shared mode order by pkAttr0, pkAttr1, coAttr4;
   Exception in thread "main" java.sql.SQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'shared mode order by pkAttr0, pkAttr1, coAttr4' at line 1
   at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:120)
   at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
   at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
   at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:953)
   at com.mysql.cj.jdbc.ClientPreparedStatement.executeQuery(ClientPreparedStatement.java:1003)
   at load.TransactionLoader.loadSelectOperation(TransactionLoader.java:131)
   at load.TransactionLoader.loadTransaction(TransactionLoader.java:53)
   at orca.Orca.main(Orca.java:118)
   ```
1. 随机生成的insert操作并不会考虑外键，这样的操作可能是无效的，这种情况怎么处理？
   ```text
   [INFO  load.TransactionLoader]   SQL is: insert into table2(pkAttr0, pkAttr1) values(?, ?);
   [INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ServerPreparedStatement[4]: insert into table2(pkAttr0, pkAttr1) values(vc10, 14);
   Exception in thread "main" java.sql.SQLIntegrityConstraintViolationException: Cannot add or update a child row: a foreign key constraint fails (`db0`.`table2`, CONSTRAINT `pk2fk_2_fkAttr0` FOREIGN KEY (`pkAttr0`) REFERENCES `table1` (`pkAttr0`))
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:117)
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
       at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
       at com.mysql.cj.jdbc.ServerPreparedStatement.serverExecute(ServerPreparedStatement.java:637)
       at com.mysql.cj.jdbc.ServerPreparedStatement.executeInternal(ServerPreparedStatement.java:418)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:1092)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:1040)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeLargeUpdate(ClientPreparedStatement.java:1347)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdate(ClientPreparedStatement.java:1025)
       at load.TransactionLoader.loadInsertOperation(TransactionLoader.java:220)
       at load.TransactionLoader.loadTransaction(TransactionLoader.java:50)
       at orca.Orca.main(Orca.java:118)
   
   Process finished with exit code 1
   ```
1. 参数填充这一步按照什么原则确定值
   ```text
   [INFO  load.TransactionLoader]   SQL is: update table2 set pkAttr0 = ? where ( NOT pkAttr0 = ? );
   Exception in thread "main" java.sql.SQLIntegrityConstraintViolationException: Duplicate entry 'vc611' for key 'table2.PRIMARY'
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:117)
       at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97)
       at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122)
       at com.mysql.cj.jdbc.ServerPreparedStatement.serverExecute(ServerPreparedStatement.java:637)
       at com.mysql.cj.jdbc.ServerPreparedStatement.executeInternal(ServerPreparedStatement.java:418)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:1092)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdateInternal(ClientPreparedStatement.java:1040)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeLargeUpdate(ClientPreparedStatement.java:1347)
       at com.mysql.cj.jdbc.ClientPreparedStatement.executeUpdate(ClientPreparedStatement.java:1025)
       at load.TransactionLoader.loadUpdateOperation(TransactionLoader.java:128)
       at load.TransactionLoader.loadTransaction(TransactionLoader.java:54)
       at orca.Orca.main(Orca.java:118)
   
   Process finished with exit code 1
   ```

## 1.27（lpy）
1. 修复了PKFunc产生负值导致取模出现负值而出现的相邻pkId产生相同主键值的问题
1. 在原先SimplePKPartitionAlg的基础上添加一个初始参数累加到pkId上作为种子，以此生成一系列表现不同的分区参数
1. 在原先SimplePKFunc基础上添加一个初始参数累加到pkId上作为种子，以此生成一系列表现不同的PKF
1. 合并wsy的BUG修复版本
1. 添加ParamType.PK2FK，事务加载部分适配ParamType.PK2FK

### 几个问题 
1. 组合操作能不能添加参数填充信息？
1. PKF真的有必要可逆吗，还是仅仅需要实现`pkId`与`具体主键值`的互相转换，
   这一操作的实现似乎不需要PKF可逆。`ATTRF`同理。

## 1.26（lpy）

1. 实现了SimplePKPartitionAlg，它接受一个静态区的产生概率作为计算参数，
   对于每一个pkId的分区结果是确定的，同时分区结果在pkId序列上随机分布，
1. 实现了SimplePKFunc，采用和上一条类似的方法，结果对特定pkId确定，在整个pkId序列上随机分布

### BUG
生成的随机插入语句出现了两次主键，可能与操作模板生成机制有关系，也可能是我之前修改的时候改出BUG了
![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210127005126.png)

## 1.23（lpy）

1. 主键列，外键列，普通列的命名分别为前缀加id，前缀定义于`Symbol`类中，三种Attribute的id独立编号，
   后面代码会假设这三种`Attribute`的前缀是这三个常量
   ```java
       public static final String COMM_ATTR_PREFIX = "coAttr";
       public static final String PK_ATTR_PREFIX = "pkAttr";
       public static final String FK_ATTR_PREFIX = "fkAttr";
   ```
   
1. 在`AbsTable`中添加了一个方法，用于根据Attr获取其所属的外键对象（如果存在的话）
   ```java
       /**
        * 找到某个 Attribute 所属的普通外键对象（不含前缀外键）
        * @param attr Attribute
        * @return 如果找到返回ForeignKey，否则null
        */
       public ForeignKey findCommFKByAttr(Attribute attr) {
           for (ForeignKey foreignKey : commonForeignKeyList) {
               if (foreignKey.getFkAttrList().contains(attr)) {
                   return foreignKey;
               }
           }
           return null;
       }
   ```

1. 在`ForeignKey`中添加了一个方法，用于根据FKAttr获取其参考的Attr
   ```java
        /**
        * 找到FKAttr所参考的的PKAttr
        * @param attr attribute
        * @return FKAttr所参考的的PKAttr
        */
       public Attribute findReferencedAttrByFkAttr(Attribute attr) {
           return referencedAttrGroup.getAttrList().get(fkAttrList.indexOf(attr));
       }
   ```

## 1.22（lpy）

### 当前实现的功能以及各部分存在的问题
1. Schema生成
   1. 外键生成规则问题，如果允许表之间存在依赖环将很难处理，当前版本对此进行了限制，保证可以根据依赖关系对表进行拓扑排序
   1. 配置项有点多，一些配置互相依赖导致难以写出合适的配置文件
1. Schema导入，这一部分直接执行即可，没啥问题
1. 生成参数的生成（DataFactory），现在没有使用配置文件，都是给出了一个非常简单的实现，之后需要完善   
1. 初始数据生成
   1. 在数据量过多时，生成特别慢且会GC OverFlow，可能是电脑内存太小，之后在集群上试试，不过远程使用集群挺麻烦的，没法调试
   1. 由于外键依赖，有时候生成的数据会导入失败，也许是现在代码中使用的规则有点问题，也可能`pkId->fkId`算法写好这个问题就解决了
1. 初始数据导入，执行代码即可，当前版本使用insert，也许可以考虑load代替，但load又不通用了
1. 事务模板生成，这一部分的问题是没有足够的信息可以用于填充参数，现在为Operation中添加了一个 `ParamFillInfo`
   用于存储之后参数填充所需的信息，目前为插入操作进行了简单适配，之后需要为其他操作进行适配，当前的 `ParamFillInfo`
   结构可以满足插入操作的需求，适配其他操作时也许需要进行改动
1. 事务加载，这一部分现在只是单线程操作，之后会涉及多线程操作，涉及到MiniShadow结构的维护以及各种锁的维护   

### 一次成功执行的输出
由于各个模块存在的BUG以及外键约束，可能需要执行好几次才能成功
   ```text
   [00:53:27.742 INFO      io.clean.Cleaner]   Directory has cleaned......
   [00:53:27.745 INFO             orca.Orca]   Start generating Schema Case......
   [00:53:27.870 INFO             orca.Orca]   Schema Case(5 KB) generation completed, 124 ms in total......
   [00:53:27.870 INFO             orca.Orca]   Loading schema to database: mysql-db0
   [00:53:28.505 INFO             orca.Orca]   Loading S U C C E S S
   [00:53:28.505 INFO             orca.Orca]   Generating initial data......
   [00:53:28.721 INFO  gen.shadow.MiniShadow]   Initiating table0...
   [00:53:28.721 INFO  gen.shadow.MiniShadow]   Initiating table1...
   [00:53:28.721 INFO  gen.shadow.MiniShadow]   Initiating table2...
   [00:53:28.736 INFO  gen.shadow.MiniShadow]   Initiating table0... FINISHED!!!
   [00:53:28.737 INFO  gen.shadow.MiniShadow]   Initiating table1... FINISHED!!!
   [00:53:28.739 INFO  gen.shadow.MiniShadow]   Initiating table2... FINISHED!!!
   [00:53:28.742 INFO             orca.Orca]   Loading initial data to database: mysql-db0
   [00:53:29.158 INFO             orca.Orca]   Start generating Operation Case......
   [00:53:29.176 INFO             orca.Orca]   Operation Case(10.8 KB) generation completed, 18 ms in total......
   [00:53:29.191 INFO  load.TransactionLoader]   SQL is: insert into table1(pk0, pk1) values(?, ?);
   [00:53:29.209 INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ServerPreparedStatement[1]: insert into table1(pk0, pk1) values(vc4450, vc2865);
   [00:53:29.210 INFO  load.TransactionLoader]   Transaction S U C C E S S
   [00:53:29.210 INFO  load.TransactionLoader]   table1 - 44 - DYNAMIC_EXISTS
   [00:53:29.210 INFO  load.TransactionLoader]   SQL is: insert into table0(pk0, pk1, attr0, attr1, attr2, attr3) values(?, ?, ?, ?, ?, ?);
   [00:53:29.211 INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ServerPreparedStatement[2]: insert into table0(pk0, pk1, attr0, attr1, attr2, attr3) values(9340, vc6360, 100.9134593334623, 100.9134593334623, 100.9134593334623, 100.9134593334623);
   [00:53:29.212 INFO  load.TransactionLoader]   Transaction S U C C E S S
   [00:53:29.212 INFO  load.TransactionLoader]   table0 - 99 - DYNAMIC_EXISTS
   [00:53:29.212 INFO  load.TransactionLoader]   SQL is: insert into table2(pk0, pk1) values(?, ?);
   [00:53:29.213 INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ServerPreparedStatement[4]: insert into table2(pk0, pk1) values(3064, vc540);
   [00:53:29.214 INFO  load.TransactionLoader]   Transaction S U C C E S S
   [00:53:29.214 INFO  load.TransactionLoader]   table2 - 33 - DYNAMIC_EXISTS
   [00:53:29.214 INFO  load.TransactionLoader]   SQL is: insert into table0(pk0, pk1, attr0, attr1, attr2, attr3) values(?, ?, ?, ?, ?, ?);
   [00:53:29.215 INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ServerPreparedStatement[5]: insert into table0(pk0, pk1, attr0, attr1, attr2, attr3) values(6538, vc4420, 70.34656827597153, 70.34656827597153, 70.34656827597153, 70.34656827597153);
   [00:53:29.216 INFO  load.TransactionLoader]   Transaction S U C C E S S
   [00:53:29.216 INFO  load.TransactionLoader]   table0 - 69 - DYNAMIC_EXISTS
   [00:53:29.216 INFO  load.TransactionLoader]   SQL is: insert into table1(pk0, pk1) values(?, ?);
   [00:53:29.217 INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ServerPreparedStatement[7]: insert into table1(pk0, pk1) values(vc2900, vc1910);
   [00:53:29.217 INFO  load.TransactionLoader]   Transaction S U C C E S S
   [00:53:29.217 INFO  load.TransactionLoader]   table1 - 29 - DYNAMIC_EXISTS
   [00:53:29.217 INFO  load.TransactionLoader]   SQL is: insert into table0(pk0, pk1, attr0, attr1, attr2, attr3) values(?, ?, ?, ?, ?, ?);
   [00:53:29.218 INFO  load.TransactionLoader]   com.mysql.cj.jdbc.ServerPreparedStatement[8]: insert into table0(pk0, pk1, attr0, attr1, attr2, attr3) values(756, vc550, 9.36198722505936, 9.36198722505936, 9.36198722505936, 9.36198722505936);
   [00:53:29.219 INFO  load.TransactionLoader]   Transaction S U C C E S S
   [00:53:29.219 INFO  load.TransactionLoader]   table0 - 8 - DYNAMIC_EXISTS
   
   Process finished with exit code 0
   
   ```

## 1.21(lpy)
1. 将`Operation`与`OperationBasic`两个类合并为`Operation`
1. 很多代码高度依赖XML配置文件，难以调试，不确定该如何修改程序结构
1. 增加了一个枚举类，存储Operation的类型
1. 暂时使TransactionCase只生成一个OperationInsert，先尝试解决这样一个简单的Transaction的参数填充问题
1. 添加了类`ParamFillInfo`，用于记录填充某一条操作模板所必需的信息，目前为`OperationInsert`添加了一个简单的实现，
   之后可能需要在所有的operation中添加这个信息，以便可以有足够的信息来进行参数填充
1. 关于`ParamFillInfo`，本来是打算在其中记录某个参数是主键、外键还是普通的Attribute，所以预留了一个`ParamType`，
   暂不确定模板生成时有没有这些信息，之后可能需要根据信息再做调整；当前在`OperationInsert`中的实现暂时读取`Attreibute`的前缀进行了判别；
   也许可以通过为`Attribute`类型附加一个`GroupType`用于指示它属于主键/外键/普通属性组

### 针对现有代码的几点程序编写建议
1. 在函数生成以及参数定义中使用 `List` 而不是直接使用 `ArrayList`，程序中我遇到的部分基本已经修改，Map相关类型也是这样
1. 尽可能使用`enum`代替一些表示类型的常量定义，比如`OperationType`，比如下图![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210121184428.png) 
1. 有些异常并不适合捕获，不如直接抛出，除非有合适的处理方法，如果非要捕获的话，请思考是否应该退出当前程序，还是出错了也可以继续执行

### 现在存在的BUG
1. 数据生成时有时因为外键而出错，需要继续优化生成这部分代码![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210121233301.png)
1. **Operation生成有时会因为随机数范围为负数而报错，出现比较频繁**![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210121233418.png)
1. 生成的事务操作列名称重复![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210122004137.png)
1. 模板填充出错，这个应该是我添加的FillInfo没有涉及外键导致的，也许可以尝试为外键属性改下名字 ![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210122012700.png)

### 接下来要做的几件事情
1. 为各种Operation添加参数填充所需信息，即`ParamFillInfo`，当前由于只适配了`OperationInsert`，就限制了事务生成模块只生成插入操作
1. 完善DataFactory中的各种算法，比如`pkId->fkId`
1. 完善MiniShadow部分
1. 完善事务的生成与加载，比如使用local miniShadow，现在只执行了一个事务，暂未考虑使用local miniShadow

### 几个难点
1. 随机Schema的依赖环问题
1. 随机Operation的有效性问题，比如生成的Insert应该符合怎么的规则，现在的很多生成结果似乎是无法插入数据库的（未验证，理由是存在外键约束问题以及NULL值）
   ![](https://cdn.jsdelivr.net/gh/lpypl/picgo-repo@main/data/20210122004343.png)
1. 一旦引入local miniShadow，该如何更新全局miniShadow,执行失败的话就不用更新了，如果执行成功，miniShadow可能已经发生了变化(在事务并行执行的情况下)

## 1.20.v2(lpy)
1. 暂时修改了外键生成部分，保证可以拓扑排序，之后可能需要再考虑下循环依赖和自身依赖的问题
1. `pkId->fkId` 的搜索，现在写的版本没有考虑所参考表的信息（比如大小），可能会生成无效
   数据，暂时在初始数据生成的代码中进行一些转换（`fkId = FKGenerator.staticFkId(pkId) % refEdTable.getTableSize()`），可能之后需要统一处理
1. 也许可以使用load等命令实现数据导入，当前实现是insert
1. 一旦schema规模变大，数据生成部分运行速度会很慢，可以尝试并行生成 [✔]

## 1.20(lpy)
1. Table与Table直接存在互相引用现象，准确的说应该是存在环，不确定这样生成的insert语句能否顺利插入数据库
1. 与上一条相关，可能需要根据外键引用规则改一下PKGenerator才能继续下一步
1. 在初始数据生成时，加上了静态区引用静态区的限制，不过现在只考虑了一次引用，没有考虑多层引用的情况
1. 修复了varchar没加引号的BUG，但是由于外键依赖，还无法插入数据库
1. 添加了Symbol类集中存储一些前缀常量
1. 现在的策略是根据依赖关系递归寻找可以初始化的表，如何存在依赖环的话，可能会无限循环

## 1.19(lpy)
1. **似乎出现了两个pkId的概念，一个是ForeignKey类型的id，一个是数据生成时的`pkId`->`fkId`**
1. 简单实现 PrimaryKey 和 Attribute 的初始化，试图外键初始化是发现比较麻烦，也许可以优化一下ForeignKey这个类

## 1.18(lpy)
1. MiniShadow部分写了一点，需要重新理一下Schema的结构，打算精简一下层次，现在的结构有点复杂
1. 去除了AllAttributeGroup这个类，直接将其维护的List<AttributeGroup>置于抽象Table中，
   因为原本的包含层级过多导致使用不便且命名有点混乱   
1. 在AbsTable类中添加了方法用于获取下一个可用的AttrGroupId和AttrId，便于保证这些Id唯一，
   之后进行Attribute和AttributeGroup操作时务必使用这两个接口进行，不要再单独维护id值，否则会发生冲突
      ```java
          /**
           * 提供下一个可用的AttrGroupId
           * @return next available AttrGroupId
           */
          public int nextAttrGroupId() {
              return availableAttrGroupId++;
          }
      
          /**
           * 提供下一个可用的AttrId
           * @return next available AttrId
           */
          public int nextAttrId() {
              return availableAttrId++;
          }
      ```
1. 删掉了AllForeignKey这个类，具体实现移至AbsTable中，简化了AbsTable层级关系，注释了AbsTable中的一些未曾使用的方法
1. 与上面类似，AbsTable增加了这样一个方法用于维护 `fkId` 的唯一性
      ```java
                /**
                 * 提供下一个可用的fkId并指向下一个
                 * @return next available fkId
                 */
                public int nextFkId() {
                    int id = availableFkId++;
                    fkCount = id + 1;
                    return id;
                }
      ```
1. 因为上述更改对相关代码进行了修正

## 1.15(lpy)
1. 修改了部分schema模块的代码，简化一些命名，添加部分注释

## 1.14(lpy)  
1. 完成了一个基础版本的generator相关类实现  
1. 增加了一个Type枚举类，使用时要和原本的int常量表示的DataType区分开  
1. 由于需要将PK具体值转换成pkId，而且可以逆向推算pkId，
   所以有必要保证其值唯一性，暂时直接将
   <img src="https://latex.codecogs.com/gif.latex?A_i + PKF(pkId) % (A_{i+1} - A_i)" />转换成字符串
1. 将`[pkIdStart,pkIdEnd)` 两个参数具体实现改成了`(pkIdStart, pkIdStep)`，意为起始值和步长
1. 数据生成接口测试

## 1.13(lpy)
1. 写了一个最基本的ParameterRepo实现，打算先把程序跑通再逐步扩充

## 1.12(lpy)
1. ValueList随机生成

## 1.10(lpy)
1. 修改外键约束SQL生成方式，一个alter语句只带一个add cons语句，尝试适配TiDB  
2. 将`DataFactory`分成两部分，`ParameterRepo`专门用于存储参数，`generator`包中的类提供外部接口  
3. 对`parameter`,`generator`,`shadow`三个包中的关键类和方法添加了说明  
4. 添加的所有函数实现时都需要仔细考虑，现有参数也许并不能满足需要，其中一个原因是一些关键转换函数的实现方式仍不确定  
5. `fkId -> 具体外键值`，`pkId -> 具体主键值`需要确认所谓的具体值的意义，具体需要记录哪些信息  

## 1.9(lpy)
1. 添加 `MiniShadow` 框架

## 1.8(lpy)
1. 添加 `DataFactory` 和 `[PK/FK/Attr]Generator` 框架

## 12.26(lpy)

1. 实现operation相关类的toSQL操作，并修改transactionCase中相关toString调用为toSQL调用

### 需要注意的问题
生成的operation_case.sql中有机率包含空行，经过debug发现这是由于readme前一条所述
**update reference操作有可能无法生成，此时`getOperationBasics`将返回一个空列表**而引起的，
在相关位置中添加了检测`toSQL()`返回值是否为空的代码，若为空则输出warn信息，供以后参考

## 12.26(wsy)

1. 实现了组合操作的生成，均继承于`operationCombination`类，可以通过`getOperationBasics`获取其中的单个操作
2. 实现了单个事务的生成，将原本的operationCase类改为transactionCase，用于生成一个完整的事务，即以start开始，commit结束，包含多个操作（或组合操作）的一连串操作，可以使用`getOperations`获取其中的单个操作（或单个组合操作）
3. 对operation相关的类追加了注释

### 需要注意的问题

update reference操作有可能无法生成，此时`getOperationBasics`将返回一个空列表

### 有待处理的问题

1. 对transactionCase类（即原来的operationCase）增加了一个构造参数id，并在测试和主程序中对应增加了，请检查是否需要修改
2. 目前组合操作的toSQL似乎还未生成，所以transactionCase的toSQL暂时用toString实现，等toSQL完善之后需要做修改

## 12.25(lpy)

1. 修复了 `log4j2` 在 linux上配置文件无法生效的bug（配置文件首字母也是小写，之前由于Windows文件系统不区分大小写而掩盖了错误）

## 12.24(lpy)
1. 添加OutAsSQL接口，使各个Operation相关类实现此接口，operation的各个组成部分负责自己的toSQL()操作，Adapter直接调用operation的toSQL()

## 12.20(wsy)

1. 实现条件是in的语句生成

## 12.19(wsy)

1. 实现了简单的参数替换，具体见`operation/OperationCase`的`updateParameter`方法
2. 实现了`Parameter`类用于传递需要的参数数量和类型
3. 修复了随机数生成`Seed`在修改生成区间后可能导致死循环的问题

#### 有待讨论||解决的问题

2. 不确定当前实现是否足以满足需求，可能需要根据需求进行迭代
3. 涉及到view的属性其属性名没有修改，依然是`tableName.attrbuteName`的形式，需要讨论其具体实现

## 12.18(lpy)

1. **改动代码比较多，主要目的是把原来的静态设定的输入/输出位置改成传参，以适应多schema操作**
1. 添加 `DataSourceConfig`，在使用 `DataSourceUtils` 之前
   需要调用 `setTestDatabase` 配置数据库，这么做是为了将 `main` 函数解耦出来，
   方便写测试方法，`DataSourceUtils` 本身由于涉及数据库访问，
   难以动态化，也就不容易在程序中配置多种数据库了，暂时只考虑一次只测试一种数据库
1. 删掉了 `SchemaCase`类，因为原本该类只是起到了包装 `Schema`并且输出 `obj` 和 `sql`的作用，
   今后的程序需要生成多个Schema对象和相应SQL，需要客制化每个Schema的路径，
   因此需要改动OutputSchemaCase类，改动之后再通过 `SchemaCase` 似乎没有太大意义
1. 因为上一条而修改了一些相关类，涉及输入输出类以及其他引用了 `SchemaCase` 的类
1. 引入 `AdapterHelper`，简化Adapter用法
1. 引入 `RawJDBCUtils` 和 `LoadSchema.loadWithRawJDBC` ，其中代码不使用 `DataSourceUtils` 获取数据库连接，
   而是使用`DriverManager`获取，便于进行并行测试

## 12.17(wsy)

1. 完成了对代码的注释和检查
2. 将原来的1.xml分离为三个文件，增强可读性
3. 修复了生成view时可能导致死循环的情况

## 12.17(lpy)

1. 新增LogUtils，实现了添加两个方法，一个方法可以设置所有Logger的级别，另一个方法可以指定某个Logger并设置级别，结合使用可以屏蔽其他类的低级别log而保留某个类的指定级别log

1. 修改main函数，将3个配置文件参数设为了可选参数，若未指定则使用默认配置

1. 配置的生成和测试又写了一部分但还未实现，存在一些问题，需要再仔细了解下schema生成过程，了解一些参数的合理范围是什么

## 12.13(wsy)

1. 合并了当前（23:33）最近版本的main

2. 初步实现了operation类中单个CRUD操作的生成，包含以下部分

   ```
   SelectOperation/InsertOperation/UpdateOperation/DeleteOperation
   OperationCase
   FromClause/WhereClause/project/LockMode/SortKey/Predicate
   ```

   以及对应的抽象类

3. 在Orca类中增加了生成operation的代码，将随机生成CRUD中的一个并输出到`schema_case/sql/operation_case.sql`中

### 有待完成的内容

1. 对上述代码的检查和整理
2. 对上述代码的注释

## 12.13 (lpy)

1. 完成schemaConfig生成模板，接下来构思生成策略
2. 重写一些涉及全局静态引用的代码，降低程序耦合度，主要涉及以下几个类
   ```
   DataFormat
   AdapterMySQL
   AdapterPostgreSQL
   SchemaCase
   Orca
   ```

## 12.12 (lpy)
1. 使用 log4j2 代替 RuntimeOutput 进行日志输出，方便测试，使用方法参见 Orca 或 OrcaTest 类
    ```
   // 此处一定要用当前类初始化 logger，方便通过配置文件控制日志级别
   private static final Logger logger = LogManager.getLogger(Orca.class);
   ...
   ...
   // 一般情况，普通信息请使用 info 输出
   logger.debug/info/warn/error(msg)
   ```

## 12.11 (lpy)
1. 去掉javaagent和sizeof.jar库，使用`org.apache.lucene.util.RamUsageEstimator`计算对象大小  
1. 新增单元测试类 `OrcaTest`
1. 修改命令行参数格式为 `dbType dbName configFile` ，去除了原有参数分割代码，最新调用参数如下
    ```
   java ...... postgresql db0 1.xml
   java ...... mysql db0 1.xml
   ```

## 更新内容 (12.10-wsy)
1. 基于lpy于12.9提交的commit[7a772d9]覆盖了原代码，具体修改见main分支的readme  
1. 修正了生成view时可能造成nullptr的问题，见`main/gen/schema/view/View` line 43-46，`main/gen/schema/Schema` line 74-78  
1. ### 可能出现的问题, 经过修复后，Table的viewList长度可能为0，据测试似乎不会出现问题，后续请注意这一点

## 更新内容（12.9-lpy）
1. MySQL 数据类型处理方法
     > (1) `integer` 类型长度修饰无实际意义，因此不加长度限制标识  
   > (2) `varchar`,`decimal`,`double` 如实添加长度修饰符  
   > (3) `blob`  根据长度选用合适的 blob类型（`tinyblob`,`blob`,`mediumblob`,`longblob`等）  
1. PostgreSQL 数据类型处理方法
      > (1) `integer`：语法不允许出现长度修饰符  
   > (2) `varchar`, `decimal`： 如实添加长度修饰符  
   > (3) `double`: 使用`double precision`  
   > (4) `blob`: 使用`bytea`

## 更新内容（12.9-lpy）
1. 解决 Pair 的依赖问题
1. 使用 String.foramt 重构一部分字符串拼接代码
1. 可以生成 SQL 文件了
1. 可以导入（MYSQL）数据库了，有一定机率失败，疑似其它模块的问题
1. 目前只对 varchar 加上了长度限制（因为 mysql 的语法规定必须这样）

## 更新内容（12.8-lpy）
1. 使用 maven 管理项目，对原来的项目结构及代码作出几点改动  
    > (1) `/model -> /src/main/resources//model`  
      (2) 基于(1)对`main` 中 `xmlPath` 获取方式做适当修改  
      (3) `src/c3p0-config.xml -> src/main/resources/c3p0-config.xml`  
      (4) 新的JVM选项：`-javaagent:"./lib/sizeof.jar"`  
      (5) 新的命令行参数：`mysql-db0 1.xml`
1. 由于原来仓库里面提交了一些无用文件，本次保留了所有源代码文件，  
   其它资源文件和配置文件并未全部保留，也许有一些有潜在用途的文件未被保留
1. 其它 *lib* 直接使用 *maven* 导入，用于 `javaagent` 的 `sizeof` 保留在 *lib* 中，  
   不过去掉了目录， `/lib/sizeof/sizeof/jar -> /lib/sizeof.jar`，  
   该库作为本地依赖导入 `maven`
   ```
   <dependency>
      <groupId>sizeof</groupId>
      <artifactId>sizeof</artifactId>
      <scope>system</scope>
      <version>1.0</version>
      <systemPath>${project.basedir}/lib/sizeof.jar</systemPath>
    </dependency>
   ```
1. *lib* 并未全部引入，只有当前运行所必需的依赖库被引入   
1. 直接运行会报和wsy分支一样的错误
    ``` 
   Dec 08, 2020 3:33:45 AM com.mchange.v2.log.MLog <clinit>
   INFO: MLog clients using java 1.4+ standard logging.
    Dec 08, 2020 3:33:45 AM com.mchange.v2.c3p0.C3P0Registry banner
    INFO: Initializing c3p0-0.9.2.1 [built 20-March-2013 10:47:27 +0000; debug? true; trace: 10]
    Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.
    Orca:2020-12-08 03:33:46.008 Directory has cleaned......
    Orca:2020-12-08 03:33:46.009 **************************************************
    Orca:2020-12-08 03:33:46.009 Start generating Schema Case......
    WARNING: An illegal reflective access operation has occurred
    WARNING: Illegal reflective access by sizeof.SizeofUtils (file:/home/lpy/IdeaProjects/orca/lib/sizeof.jar) to field java.util.LinkedHashMap.head
    WARNING: Please consider reporting this to the maintainers of sizeof.SizeofUtils
    WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
    WARNING: All illegal access operations will be denied in a future release
    Exception in thread "main" java.lang.reflect.InaccessibleObjectException: Unable to make field private static final jdk.internal.reflect.ReflectionFactory jdk.internal.reflect.ReflectionFactory.soleInstance accessible: module java.base does not "opens jdk.internal.reflect" to unnamed module @6bf0219d
        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:349)
        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:289)
        at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:174)
        at java.base/java.lang.reflect.Field.setAccessible(Field.java:168)
        at sizeof.SizeofUtils.getNodeSize(SizeofUtils.java:89)
        at sizeof.SizeofUtils.internalSizeOf(SizeofUtils.java:62)
        at sizeof.SizeofUtils.fullSizeOf(SizeofUtils.java:39)
        at orca.Orca.generateSchemaCase(Orca.java:65)
        at orca.Orca.main(Orca.java:50)
   ```
1. `.gitignore`添加 `target` 和 `schema_case`
    ```
    /target/**
    /schema_case/**
    ```

### 更新内容（12.7）

-2.将项目改成使用maven管理jar包 交给刘沛源完成

-1.修改了model中的一些命名和结构 翁思扬简单看一下是否有问题。

0.新增dataformat类，model那一块还需要修改，交给翁思扬完成

1.新增adapter模块，输入：schema case数据结构，输出：满足特定数据库语法的SQL 删除了sql.schema和transaction，将这一块代码封装到adapter中。 结合dataformat，先适配MySQL，交给刘沛源完成 OutputSchemaCase.outputSQL这一方法还需要修改，交给刘沛源完成

2.新增util.jdbc模块，将jdbc所需要的相关API封装在工具类里，利用数据源c3p0，配合原始jdbc一块用

3.新增load.schema，将schema case导入数据库中 利用jdbc,编写LoadSchema模块的代码，交给刘沛源完成

5.Orca.main新增了指定导入数据库和初始化jdbc的相关代码

6.整个程序尚未跑通，刘沛源和翁思扬合作完成整个工作

### 更新内容(WSY)

1. 修改了model中的一些命名和结构

2. 新增dataformat类，修改了对应的xml结构，具体如下

   ```XML
   <data>
   		<format>
   			<integer>
   				<length_limit>11</length_limit>
   			</integer>
   			<varchar>
   				<length_limit>255</length_limit>
   			</varchar>
   			<double_decimal>
   				<decimal_precision_limit>10</decimal_precision_limit>
   				<decimal_scale_limit>0</decimal_scale_limit>
   				<double_precision_limit>38</double_precision_limit>
   				<double_scale_limit>17</double_scale_limit>
   			</double_decimal>
   			<blob>
   				<length_limit>255</length_limit>
   			</blob>
   		</format>
   	</data>
   ```

## reform(12.6-wsy)

### 更新内容

本次主要调整了代码的结构

**太长不看版：基本按学长给出的结构做的调整，但没有实现common foreign key 和 Prefix Foreign Key类，而是直接用array list保存对应内容。另外，abstract table类内原本封装了大量的方法，不清楚以后会不会用到，所以都保留了**

现逻辑结构如下，（只显示从属关系，如长度，数量等信息隐去

- schema
   - array list: table
      - index
         - primary key
         - array list: foreign key
         - array list: attribute groups
      - other values from abstract table
   - array list: view
      - join
         - tables
- abstract table
   - primary key
      - attribute group
         - array list: attribute
   - all attribute group
      - array list: attribute group
         - array list: attribute
   - all foreign key
      - foreign key: primaryKey2ForeignKey
         - attribute group
            - array list: attribute
         - referenced table
      - array list: common foreign key
         - foreign key
            - attribute group
               - array list: attribute
            - referenced table

### 可能出现的问题

作为编写代码的人，我感觉挺清晰的。但不确定是不是因为最近写得多了所以自然就熟悉了。。。。

## schema/view (12.4)

### 更新内容

本次主要更新了`/src/gen/schema/view`目录下，生成view部分的内容。

1. view

   重写了生成合并路径的算法，采用随机游走的方式；因为单纯随机游走的命中率可能不高，**额外**支持随机游走不止一条出边的方法（即每次失败不是从路径的起点重新开始，而是从上个节点重新游走）。

   改写了attribute的命名方式，追加了一些注释

2. join

   根据新的路径结构，重写了生成join的算法。主要是修改了命名规则和一些对应的逻辑，主体流程没有太大的改变

3. 成功将Histogram类退环境

   将原本的histogram类相关的随机数生成算法完全替代，删除了对应的包

### 可能出现的问题

实现的逻辑没有发现问题。

目前小数据经手工测试是符合SQL语法的，且暂未发现结果在逻辑上有问题。但由于采用的生成数据不大，暂不清楚在大样本下是否会出现奇怪的现象。

## schema/table（11.29）

### 更新内容

本次主要更新了`/src/gen/schema/table`目录下，生成schema部分的内容。

1. Attribute：

   修改了attributes类，重写了使用随机数生成部分的逻辑，换用了新的随机数生成种子和对应代码（`Seed`）。同时，追加了用随机数分组的代码，生成以组为单位的列表`ArrayList<ArrayList<Attribute>>GroupList`，对每组生成组长度，然后随机生成对应数量的属性，封装了对应的接口

   **注意**，原本的`attributeList`暂时没有删除，因为在一些地方还需要直接调用全部属性。

   对Attribute类做了一点微小的调整，主要是对于varchar类型的生成，其长度参数的必须性对于不同SQL数据库似乎是不同的，**这里需要进一步的讨论**

2. PrimaryKey：

   修改了primaryKey类，重写了使用随机数生成部分的逻辑，换用了新的随机数生成种子和对应代码（`Seed`）

3. ForeignKey:

   对这部分代码进行了大修，目前生成外键的逻辑如下：

   1. 等全部表的主键和属性生成完之后再生成外键约束关系；
   2. 对于COFK，将参考被参考的表的外键生成新的属性，插入attributes中，因此外键里存储的属性实际上在Table的Attributes已经有存储，对应地修改了输出schema时的代码
   3. 对于PK2FK，选取参考表时需要通过随机数得到搜索的起始位置，然后循环进行搜索匹配。匹配时着重判定了属性的对应关系和键的长度，如果不满足则继续搜索，如果搜索不到直接放弃。
   4. 因为先后关系难以判断，在生成schema的语句中去除了声明外键的部分；改为在全部schema生成完后以`alter`的形式生成外键约束关系

   目前这部分代码已经基本完成，但因为代码逻辑比较复杂，写得有点冗长，不确定是否有实现问题，**需要详细地代码检查**

   暂未修改外键依赖图内部的代码，在全部外键生成完之后调用这部分代码加边。预计等确定了view部分之后再视需要对应的进行修改

4. Index

   index类进行了小修改，主要是生成attribute的索引的部分改为以属性组为单位。同时完善了输出的SQL语句，同样是使用`alter add`的形式添加

5. 对SQL的输出语句进行了修改，以符合上述部分的描述和SQL语法。

6. 修改了一些遗留问题

### 可能存在的问题

1. 首先是外键生成的逻辑，不确定生成算法是否满足要求，以及实现上可能出现的问题
2. 在目前的实现下，通过构造模型可以实现环形依赖，但一般生成环形依赖的概率是很低的
3. 因为外键的生成依赖于原有的属性，模型构建时需要一定的技巧，目前尚没有对不合适的模型参数（随机数参数）进行警告，也不容易对其进行警告



## Seed（11.24）

对随机数模块的代码逻辑进行以下调整：

原本生成对应特征的流程：

1. 实例化类Histogram并输入参数
2. 在类中通过一定逻辑选定interval并通过interval的参数生成随机数

修改后的流程：

1. 通过SeedUtils实例化类Seed并输入参数
2. 在Seed类中读入XML参数seed，根据参数选择使用的分布和生成区间，实例化分布器
3. 通过分布器生成随机数

实例见`src\gen\schema\Schema`中，生成numberTable的部分

### 新的XML格式

经过调整后，原本`<histogram><\histogram>`对应的内容应组织为以下格式

```
 <seed>
     <begin>区间起点</begin>
     <end>区间终点</end>
     <distribution>分布类型[Uniform|Normal|Zipf],参数...</distribution>
 </seed>
```

具体样例见`\model\1.xml`

### 可能存在的问题

在手动测试中暂未发现问题，可以正常调用`util.access.distribution`中的三个分布类生成随机数。但由于不熟悉序列化相关的内容，Seed类是直接在原Interval类的代码基础上进行重写的，不清楚是否会因此出现问题。